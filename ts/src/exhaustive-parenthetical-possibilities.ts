import { expect } from 'chai';

/*
Write a function, parentheticalPossibilities, that takes in a string as an argument. The function should return an array containing all of the strings that could be generated by expanding all parentheses of the string into its possibilities.

For example, the possibilities for 'x(mn)yz' are 'xmyz', 'xnyz'.

### Approach

Iterate through the string.
For any character, add it to a prefix string.
For any opening parentheses, branch and recurse for each character
until a closing parentheses. Pass down a sliced string that excludes
the prefix and includes one each of the characters from inside the
parentheses:

          a(bc)d(ef)
   │     prefix = a
   │     ┌─────┴─────┐
   │    bd(ef)      cd(ef)
   │     bd          cd
   │  ┌──┴──┐     ┌──┴──┐
   ↓  e     f     e     f

When returning, concat each branch with the current prefix string:

   ↑       a(bc)d(ef)
   │ [abde,abdf,acde,acdf]
   │     ┌─────┴─────┐
   │   bd(ef)      cd(ef)
   │ [bde,bdf]   [cde, cdf]
   │  ┌──┴──┐     ┌──┴──┐
   │  e     f     e     f

Complexity:

n = string length (number of groups)
m = max group size

Time: ~O(m^n)
Space: ~O(m^n)

*/
// function parentheticalPossibilities(s: string): string[] {
//   const result: string[] = [];
//   let prefix = ''; // prefix = x
//   let i = 0; // i = 1
//   let char = s[i]; // char = (
//
//   while (char !== '(' && i < s.length) {
//     prefix += char;
//     i += 1;
//     char = s[i];
//   }
//
//   if (char === '(') {
//     const branches = []; // branches = [m,n]
//     let j = i + 1; // j = 4
//     char = s[j]; // char = )
//     while (char !== ')' && j < s.length) {
//       branches.push(char);
//       j++;
//       char = s[j];
//     }
//     for (let branch of branches) {
//       const possibilities = parentheticalPossibilities(
//         `${branch}${s.slice(i + branches.length + 2)}`
//       );
//       for (let possibility of possibilities) {
//         result.push(prefix + possibility);
//       }
//     }
//   } else {
//     result.push(prefix);
//   }
//
//   return result;
// }

function parentheticalPossibilities(s: string): string[] {
  if (s.length === 0) return [''];

  const { prefix, suffix } = parse(s);
  const subPossibilities = parentheticalPossibilities(suffix);
  const possibilities: string[] = [];
  for (let char of prefix) {
    for (let subPossibility of subPossibilities) {
      possibilities.push(char + subPossibility);
    }
  }
  return possibilities;
}

function parse(s: string) {
  if (s[0] === '(') {
    const end = s.indexOf(')');
    return {
      prefix: s.slice(1, end),
      suffix: s.slice(end + 1),
    };
  } else {
    return {
      prefix: s[0],
      suffix: s.slice(1),
    };
  }
}

// test_00:
expect(parentheticalPossibilities('x(mn)yz')).to.deep.equal(['xmyz', 'xnyz']);

// test_01:
expect(parentheticalPossibilities('(qr)ab(stu)c')).to.deep.equal([
  'qabsc',
  'qabtc',
  'qabuc',
  'rabsc',
  'rabtc',
  'rabuc',
]);

// test_02:
expect(parentheticalPossibilities('taco')).to.deep.equal(['taco']);

// test_03:
expect(parentheticalPossibilities('')).to.deep.equal(['']);

// test_04:
expect(parentheticalPossibilities('(etc)(blvd)(cat)')).to.deep.equal([
  'ebc',
  'eba',
  'ebt',
  'elc',
  'ela',
  'elt',
  'evc',
  'eva',
  'evt',
  'edc',
  'eda',
  'edt',
  'tbc',
  'tba',
  'tbt',
  'tlc',
  'tla',
  'tlt',
  'tvc',
  'tva',
  'tvt',
  'tdc',
  'tda',
  'tdt',
  'cbc',
  'cba',
  'cbt',
  'clc',
  'cla',
  'clt',
  'cvc',
  'cva',
  'cvt',
  'cdc',
  'cda',
  'cdt',
]);
